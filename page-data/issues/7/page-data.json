{"componentChunkName":"component---src-templates-issues-tsx","path":"/issues/7","result":{"data":{"site":{"siteMetadata":{"repo":"https://github.com/lencx/dev"}},"issuesJson":{"id":"8aed031e-b180-531d-aa27-1b93d3fed974","title":"Event loop：宏任务与微任务","number":7,"bodyHTML":"<h2 dir=\"auto\">事件循环</h2>\n<p dir=\"auto\">在计算机领域中事件循环（event loop），又称为消息分发器（message dispatcher）、消息循环（message loop）、消息泵（message pump）或运行循环（run loop），是一种程序构造或设计模式，负责等待并分发程序中的事件或消息。它的工作方式是向内部或者外部的“事件提供方”发出请求（请求通常会被阻塞，直到有新事件产生），待请求被处理后调用所获得的事件对应的回调函数（即“分发事件”）。</p>\n<p dir=\"auto\">事件循环可以与<a href=\"https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F\" rel=\"nofollow\">反应器</a>（reactor）结合使用，只要事件提供方采用可以被 poll（指类似 <a href=\"https://zh.wikipedia.org/wiki/Select_(Unix)\" rel=\"nofollow\">select</a>、<a href=\"https://zh.wikipedia.org/wiki/Epoll\" rel=\"nofollow\">epoll</a> 的系统调用，不是指<a href=\"https://zh.wikipedia.org/wiki/%E8%BC%AA%E8%A9%A2\" rel=\"nofollow\">轮询</a>）的文件接口。事件循环几乎总是与消息发起方异步地执行。</p>\n<p dir=\"auto\">当一个事件循环构成程序的中心<a href=\"https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B\" rel=\"nofollow\">控制流</a>时（通常是这样），可以称之为主循环或者主事件循环。这些名称是合适的，因为这样的事件循环位于程序控制流的最顶层。</p>\n<p dir=\"auto\">事件循环是实现进程间通信的方法之一。</p>\n<h2 dir=\"auto\">JS 中的事件循环</h2>\n<blockquote>\n<p dir=\"auto\">事件循环的概念非常简单。有一个无限循环，JavaScript 引擎等待任务，执行它们然后休眠，等待更多任务。</p>\n</blockquote>\n<ul dir=\"auto\">\n<li>宏任务： <a href=\"https://developer.mozilla.org/docs/Web/API/WindowTimers/setTimeout\" rel=\"nofollow\">setTimeout</a>、<a href=\"https://developer.mozilla.org/docs/Web/API/WindowTimers/setInterval\" rel=\"nofollow\">setInterval</a>、<a href=\"https://developer.mozilla.org/docs/Web/API/Window/setImmediate\" rel=\"nofollow\">setImmediate</a>、<a href=\"https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame\" rel=\"nofollow\">requestAnimationFrame</a>、<a href=\"https://developer.mozilla.org/docs/Mozilla/Projects/NSPR/Reference/I_O_Functions\" rel=\"nofollow\">I/O</a>、UI 渲染</li>\n<li>微任务： <a href=\"https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/\" rel=\"nofollow\">process.nextTick</a>、<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\" rel=\"nofollow\">Promises</a>、<a href=\"https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask\" rel=\"nofollow\">queueMicrotask</a>、<a href=\"https://developer.mozilla.org/docs/Web/API/MutationObserver\" rel=\"nofollow\">MutationObserver</a></li>\n</ul>\n<h2 dir=\"auto\">Node.js</h2>\n<h3 dir=\"auto\">什么是事件循环 (What is the Event Loop)?</h3>\n<p dir=\"auto\">事件循环是 Node.js 处理非阻塞 I/O 操作的机制——尽管 JavaScript 是单线程处理的——当有可能的时候，它们会把操作转移到系统内核中去。<br>\n目前大多数内核都是多线程的，它们可在后台处理多种操作。当其中的一个操作完成的时候，内核通知 Node.js 将适合的回调函数添加到<code class=\"notranslate\">轮询</code>队列中等待时机执行。</p>\n<h3 dir=\"auto\">事件循环机制解析 (Event Loop Explained)</h3>\n<p dir=\"auto\">当 Node.js 启动后，它会初始化事件循环，处理已提供的输入脚本（或丢入到 <a href=\"https://nodejs.org/api/repl.html#repl_repl\" rel=\"nofollow\">REPL</a>），它可能会调用一些异步的 API、调度定时器，或者调用 process.nextTick()，然后开始处理事件循环。</p>\n<div class=\"highlight highlight-source-shell notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"# 事件循环操作顺序的简化概览\n\n# 1. 每个框为事件循环机制的一个阶段\n# 2. 每个阶段都有一个 FIFO 队列来执行回调\n\n   ┌───────────────────────────┐\n┌─&gt;│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │&lt;─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\"><pre><span class=\"pl-c\"><span class=\"pl-c\">#</span> 事件循环操作顺序的简化概览</span>\n\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> 1. 每个框为事件循环机制的一个阶段</span>\n<span class=\"pl-c\"><span class=\"pl-c\">#</span> 2. 每个阶段都有一个 FIFO 队列来执行回调</span>\n\n   ┌───────────────────────────┐\n┌─<span class=\"pl-k\">&gt;</span>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<span class=\"pl-k\">&lt;</span>─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘</pre></div>\n<ul dir=\"auto\">\n<li><strong><code class=\"notranslate\">timers</code></strong>: 定时器 - 本阶段执行已经被 <code class=\"notranslate\">setTimeout()</code> 和 <code class=\"notranslate\">setInterval()</code> 的调度回调函数。</li>\n<li><strong><code class=\"notranslate\">pending callbacks</code></strong>: 待定回调 - 执行延迟到下一个循环迭代的 I/O 回调。</li>\n<li><strong><code class=\"notranslate\">idle, prepare</code></strong>: 仅系统内部使用。</li>\n<li><strong><code class=\"notranslate\">poll</code></strong>: 轮询 - 检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，那些由计时器和 <code class=\"notranslate\">setImmediate()</code> 调度的之外），其余情况 node 将在适当的时候在此阻塞。此阶段有两个重要功能：\n<ol dir=\"auto\">\n<li>计算应该阻塞和轮询 I/O 的时间。</li>\n<li>然后，处理 <code class=\"notranslate\">轮询</code> 队列里的事件。</li>\n</ol>\n</li>\n<li><strong><code class=\"notranslate\">check</code></strong>: 检测 - <code class=\"notranslate\">setImmediate()</code> 回调函数在这里执行。</li>\n<li><strong><code class=\"notranslate\">close callbacks</code></strong>: 关闭的回调函数 - 一些关闭的回调函数，如：<code class=\"notranslate\">socket.on('close', ...)</code>。</li>\n</ul>\n<p dir=\"auto\">在每次运行的事件循环之间，Node.js 检查它是否在等待任何异步 I/O 或计时器，如果没有的话，则完全关闭。</p>\n<hr>\n<h2 dir=\"auto\">参考资料</h2>\n<ul dir=\"auto\">\n<li><a href=\"https://en.wikipedia.org/wiki/Event_loop\" rel=\"nofollow\">wiki  Event loop</a></li>\n<li><a href=\"https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context\" rel=\"nofollow\">Difference between microtask and macrotask within an event loop context</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" rel=\"nofollow\">[MDN] 并发模型与事件循环</a></li>\n<li><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" rel=\"nofollow\">The Node.js Event Loop, Timers, and process.nextTick()</a></li>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5\" rel=\"nofollow\">How JavaScript works: Event loop and the rise of Async programming + 5 ways to better coding with async/await</a></li>\n</ul>","updatedAt":"2022-07-25T10:30:42Z","upvoteCount":1,"author":{"login":"lencx","avatarUrl":"https://avatars.githubusercontent.com/u/16164244?u=77d1d01930d8e36105a49a6c474abf70eeee74b1&v=4","url":"https://github.com/lencx"},"category":{"isAnswerable":false,"name":"Web","emoji":":globe_with_meridians:"},"labels":{"edges":[{"node":{"name":"JavaScript","color":"f1e05a"}},{"node":{"name":"Blog","color":"222222"}}]},"comments":{"edges":[]}}},"pageContext":{"number":7,"previous":{"title":"Awesome Dev Tools","number":9},"next":{"title":"Awesome Miniprogram","number":38}}},"staticQueryHashes":["3993188973"]}