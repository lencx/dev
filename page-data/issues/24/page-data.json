{"componentChunkName":"component---src-templates-issues-tsx","path":"/issues/24","result":{"data":{"site":{"siteMetadata":{"repo":"https://github.com/lencx/dev"}},"issuesJson":{"id":"53f8edbc-6804-5684-bbf4-076f2bc7d621","title":"js 中的语句 & 表达式 & 分号","number":24,"bodyHTML":"<ul dir=\"auto\">\n<li>语句是一段可以执行并执行某种操作的代码</li>\n<li>表达式是一段代码，可以对其进行求值以产生一个值</li>\n<li>表达式可以用作语句，被称为表达式语句。反之则不然：当上下文需要表达式时，不能使用语句</li>\n<li>每条语句都以分号结尾</li>\n<li>以块结尾的语句\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"function foo() {\n  // ...\n}\nif (x &gt; 0) {\n  // ...  \n}\"><pre><span class=\"pl-k\">function</span> <span class=\"pl-en\">foo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// ...</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-k\">if</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span> <span class=\"pl-c1\">&gt;</span> <span class=\"pl-c1\">0</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-c\">// ...  </span>\n<span class=\"pl-kos\">}</span></pre></div>\n</li>\n<li>控制语句的主体本身就是一个语句\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"while (condition)\n  statement\"><pre><span class=\"pl-k\">while</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">condition</span><span class=\"pl-kos\">)</span>\n  <span class=\"pl-s1\">statement</span></pre></div>\n</li>\n</ul>\n<hr>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// 表达式 `bar()` 可以是表达式或语句——这取决于上下文\nfunction foo() {\n  console.log(bar()) // bar() 是表达式\n  bar(); // bar(); 是表达式语句\n}\"><pre><span class=\"pl-c\">// 表达式 `bar()` 可以是表达式或语句——这取决于上下文</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">foo</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-en\">bar</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">)</span> <span class=\"pl-c\">// bar() 是表达式</span>\n  <span class=\"pl-en\">bar</span><span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span> <span class=\"pl-c\">// bar(); 是表达式语句</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// 函数声明\nfunction foo(x) {\n  return x;\n}\n\n// 函数表达式（=右侧）\nconst fooo = function bar(x) {\n  return x;\n}\"><pre><span class=\"pl-c\">// 函数声明</span>\n<span class=\"pl-k\">function</span> <span class=\"pl-en\">foo</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n\n<span class=\"pl-c\">// 函数表达式（=右侧）</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-en\">fooo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-k\">function</span> <span class=\"pl-en\">bar</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span>\n  <span class=\"pl-k\">return</span> <span class=\"pl-s1\">x</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// 对象字面量\nconst obj = {};\n\n// 空代码块\n{\n}\"><pre><span class=\"pl-c\">// 对象字面量</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-s1\">obj</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// 空代码块</span>\n<span class=\"pl-kos\">{</span>\n<span class=\"pl-kos\">}</span></pre></div>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// 整个 const 声明（一个语句）以分号结尾，但在它里面，有一个箭头函数表达式。\n// 也就是说，它本身并不是以花括号结尾的语句；\n// 它是嵌入的箭头函数表达式。 这就是为什么末尾有一个分号。\nconst foo = () =&gt; {}; \"><pre><span class=\"pl-c\">// 整个 const 声明（一个语句）以分号结尾，但在它里面，有一个箭头函数表达式。</span>\n<span class=\"pl-c\">// 也就是说，它本身并不是以花括号结尾的语句；</span>\n<span class=\"pl-c\">// 它是嵌入的箭头函数表达式。 这就是为什么末尾有一个分号。</span>\n<span class=\"pl-k\">const</span> <span class=\"pl-en\">foo</span> <span class=\"pl-c1\">=</span> <span class=\"pl-kos\">(</span><span class=\"pl-kos\">)</span> <span class=\"pl-c1\">=&gt;</span> <span class=\"pl-kos\">{</span><span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span> </pre></div>\n<h2 dir=\"auto\">消除歧异</h2>\n<p dir=\"auto\">歧义只是语句上下文中的问题：如果 JavaScript 解析器遇到歧义语法，它不知道它是普通语句还是表达式语句。 例如：</p>\n<ul dir=\"auto\">\n<li>如果语句以函数开头：它是函数声明还是函数表达式？</li>\n<li>如果语句以 <code class=\"notranslate\">{</code> 开头：它是对象字面量还是代码块？</li>\n</ul>\n<p dir=\"auto\">为了解决歧义，以 <code class=\"notranslate\">function</code> 或 <code class=\"notranslate\">{</code> 开头的语句永远不会被解释为表达式。如果希望表达式语句以这些标记之一开头，则必须将其括在括号中。</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// -------- (a) 创建函数 -------- | (b) 调用函数\n(function (x) { console.log(x) })('abc');\n\n// (a) 中的代码片段被解释为表达式，因为将其包裹在括号中。\n// 如果不这样做，会得到一个语法错误，因为 JavaScript 需要一个函数声明并抱怨缺少函数名。\n// 此外，不能在函数声明之后立即进行函数调用。\n// Uncaught SyntaxError: Function statements require a function name\"><pre><span class=\"pl-c\">// -------- (a) 创建函数 -------- | (b) 调用函数</span>\n<span class=\"pl-kos\">(</span><span class=\"pl-k\">function</span> <span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">{</span> <span class=\"pl-smi\">console</span><span class=\"pl-kos\">.</span><span class=\"pl-en\">log</span><span class=\"pl-kos\">(</span><span class=\"pl-s1\">x</span><span class=\"pl-kos\">)</span> <span class=\"pl-kos\">}</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">(</span><span class=\"pl-s\">'abc'</span><span class=\"pl-kos\">)</span><span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// (a) 中的代码片段被解释为表达式，因为将其包裹在括号中。</span>\n<span class=\"pl-c\">// 如果不这样做，会得到一个语法错误，因为 JavaScript 需要一个函数声明并抱怨缺少函数名。</span>\n<span class=\"pl-c\">// 此外，不能在函数声明之后立即进行函数调用。</span>\n<span class=\"pl-c\">// Uncaught SyntaxError: Function statements require a function name</span></pre></div>\n<h2 dir=\"auto\">自动插入分号</h2>\n<blockquote>\n<p dir=\"auto\">Automatic semicolon insertion (ASI)</p>\n</blockquote>\n<p dir=\"auto\">ASI 的工作原理如下。语句的解析继续进行，直到出现以下任一情况：</p>\n<ul dir=\"auto\">\n<li>分号</li>\n<li>行终止符后跟非法标记</li>\n</ul>\n<p dir=\"auto\">换句话说，ASI 可以看作是在换行符处插入分号。</p>\n<div class=\"highlight highlight-source-js notranslate position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"return\n{\n\tname: 'lencx'\n};\n\n\n// 解析后\nreturn;\n{\n  name: 'lencx';\n}\n;\n\n// 1. 不带操作数的返回语句：return;\n// 2. 代码块的开始：{\n// 3. 表达式语句 'lencx'，标签 name\n// 4. 代码块结束：}\n// 5. 空语句：;\n// 为什么 JavaScript 会这样做？ 它可以防止在返回后意外返回一行中的值。\"><pre><span class=\"pl-k\">return</span>\n<span class=\"pl-kos\">{</span>\n\t<span class=\"pl-c1\">name</span>: <span class=\"pl-s\">'lencx'</span>\n<span class=\"pl-kos\">}</span><span class=\"pl-kos\">;</span>\n\n\n<span class=\"pl-c\">// 解析后</span>\n<span class=\"pl-k\">return</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">{</span>\n  name: <span class=\"pl-s\">'lencx'</span><span class=\"pl-kos\">;</span>\n<span class=\"pl-kos\">}</span>\n<span class=\"pl-kos\">;</span>\n\n<span class=\"pl-c\">// 1. 不带操作数的返回语句：return;</span>\n<span class=\"pl-c\">// 2. 代码块的开始：{</span>\n<span class=\"pl-c\">// 3. 表达式语句 'lencx'，标签 name</span>\n<span class=\"pl-c\">// 4. 代码块结束：}</span>\n<span class=\"pl-c\">// 5. 空语句：;</span>\n<span class=\"pl-c\">// 为什么 JavaScript 会这样做？ 它可以防止在返回后意外返回一行中的值。</span></pre></div>\n<hr>\n<ul dir=\"auto\">\n<li><a href=\"https://exploringjs.com/impatient-js/ch_syntax.html#statement-vs-expression\" rel=\"nofollow\">Statement vs. expression</a></li>\n<li><a href=\"https://exploringjs.com/impatient-js/ch_control-flow.html#labels\" rel=\"nofollow\">break plus label: leaving any labeled statement</a></li>\n</ul>","updatedAt":"2022-03-30T03:55:00Z","upvoteCount":1,"author":{"login":"lencx","avatarUrl":"https://avatars.githubusercontent.com/u/16164244?u=77d1d01930d8e36105a49a6c474abf70eeee74b1&v=4","url":"https://github.com/lencx"},"category":{"isAnswerable":false,"name":"Web","emoji":":globe_with_meridians:"},"labels":{"edges":[{"node":{"name":"JavaScript","color":"f1e05a"}}]},"comments":{"edges":[]}}},"pageContext":{"number":24,"previous":{"title":"在线翻译 & APP","number":22},"next":{"title":"解决 mac 中使用 npm 命令必须要加 sudo","number":27}}},"staticQueryHashes":["3993188973"]}